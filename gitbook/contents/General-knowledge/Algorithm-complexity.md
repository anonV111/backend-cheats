### Algorithm complexity

<p align="center"><img src="./files/common/BigO_eng.png" alt="BigO"/></p>

In the world of programming there is a special unit of measure [Big O notation](https://en.m.wikipedia.org/wiki/Big_O_notation). It describes how the complexity of an algorithm increases with the amount of input data. Big O estimates how many actions (steps/iterations) it takes to execute the algorithm, while always showing the worst case scenario.

-   Main types of complexity
    > -   Constant O(1) â€“ the fastest. <br>
    > -   Linear O(n) <br>
    > -   Logarithmic O(log n) <br>
    > -   Linearimetric O(n \* log n) <br>
    > -   Quadratic O(n^2) <br>
    > -   Stepwise O(2^n) <br>
    > -   Factorial O(n!) â€“ the slowest. <br>
-   [Time complexity](https://en.wikipedia.org/wiki/Time_complexity)
    > When you know in advance on which machine the algorithm will be executed, you can measure the execution time of the algorithm. Again, on very good hardware the execution time of the algorithm can be quite acceptable, but the same algorithm on a weaker hardware can run for hundreds of milliseconds or even a few seconds. Such delays will be very sensitive if your application handles user requests over the network.
-   [Space complexity](https://en.wikipedia.org/wiki/Space_complexity)
    > In addition to time, you need to consider how much memory is spent on the work of an algorithm. It is important when you're working with limited memory resources.

<details>
<summary>ðŸ”— <b>References</b></summary>

1. ðŸ“„ [**Big O Algorithm Complexity cheatsheet**](https://www.bigocheatsheet.com/)
2. ðŸ“º [**Big O Notation - Full Course** â€“ YouTube](https://youtu.be/Mo4vesaut8g)
 </details>


